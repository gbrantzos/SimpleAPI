using System.Globalization;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SimpleAPI.Generator;

public readonly record struct TypedDetails(string Name, string Namespace)
{
    public readonly string Name = Name;
    public readonly string Namespace = Namespace;
};

[Generator(LanguageNames.CSharp)]
public class StronglyTypedIDs : IIncrementalGenerator
{
    public const string AttributeName = "StronglyTypedIDAttribute";
    public const string AttributeCode =
        $$$"""
           namespace SimpleAPI.Core
           {
               [System.AttributeUsage(System.AttributeTargets.Class)]
               public class {{{AttributeName}}} : System.Attribute { }
           }
           """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "SimpleAPI.Generator.Common.g.cs",
            SourceText.From(AttributeCode, Encoding.UTF8)));

        var entityTypes = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                $"SimpleAPI.Core.{AttributeName}",
                predicate: (node, _) => node is ClassDeclarationSyntax,
                transform: GetTypeDetails
            )
            .Where(static m => m is not null);

        context.RegisterSourceOutput(entityTypes, Execute);
    }

    private static void Execute(SourceProductionContext context, TypedDetails? details)
    {
        // Safety...
        if (details is not { } dt) return;

        var stronglyTypedID = PrepareCode(dt.Name, dt.Namespace);
        context.AddSource($"SimpleAPI.Generator.{dt.Name}.StronglyTypedID.g.cs", stronglyTypedID);
    }

    private static TypedDetails? GetTypeDetails(GeneratorAttributeSyntaxContext context,
        CancellationToken token)
    {
        // Safety
        if (context.TargetSymbol is not INamedTypeSymbol classSymbol) return null;
        token.ThrowIfCancellationRequested();

        var symbolName = classSymbol.Name;
        var symbolNamespace = classSymbol.ContainingNamespace.ToString();
        return new TypedDetails(symbolName, symbolNamespace);
    }

    private static string PrepareCode(string symbolName, string symbolNamespace)
    {
        // https://andrewlock.net/strongly-typed-id-updates/
        return $$"""
                 //------------------------------------------------------------------------------
                 // <auto-generated>
                 //     This code was generated by source generator
                 //
                 //     Changes to this file may cause incorrect behavior and will be lost if
                 //     the code is regenerated.
                 //
                 //     Created at: {{DateTime.UtcNow.ToString("yyyy/MM/dd HH:mm:ss", CultureInfo.InvariantCulture)}}
                 // </auto-generated>
                 //------------------------------------------------------------------------------
                 #nullable enable

                 using SimpleAPI.Domain.Base;
                 using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

                 namespace {{symbolNamespace}};

                 public readonly struct {{symbolName}}ID : IComparable<{{symbolName}}ID>, IEquatable<{{symbolName}}ID>, IEntityID
                 {
                     public int Value { get; }
                     public bool IsNew => Value == 0;
                 
                     public {{symbolName}}ID(int value) => Value = value;
                     
                     public bool Equals({{symbolName}}ID other) => this.Value.Equals(other.Value);
                     public int CompareTo({{symbolName}}ID other) => Value.CompareTo(other.Value);
                 
                     public override bool Equals(object? obj)
                     {
                         if (ReferenceEquals(null, obj)) return false;
                         return obj is {{symbolName}}ID other && Equals(other);
                     }
                 
                     public override int GetHashCode() => Value.GetHashCode();
                     public override string ToString() => Value.ToString();
                 
                     public static bool operator ==({{symbolName}}ID a, {{symbolName}}ID b) => a.CompareTo(b) == 0;
                     public static bool operator !=({{symbolName}}ID a, {{symbolName}}ID b) => !(a == b);
                     
                     public static bool operator <({{symbolName}}ID left, {{symbolName}}ID right) => left.CompareTo(right) < 0;
                     public static bool operator <=({{symbolName}}ID left, {{symbolName}}ID right) => left.CompareTo(right) <= 0;
                     public static bool operator >({{symbolName}}ID left, {{symbolName}}ID right) => left.CompareTo(right) > 0;
                     public static bool operator >=({{symbolName}}ID left, {{symbolName}}ID right) => left.CompareTo(right) >= 0;
                     
                     public class EFValueConverter : ValueConverter<{{symbolName}}ID, int>
                     {
                         public EFValueConverter() : base(
                            v => v.Value,
                            v => new {{symbolName}}ID(v)
                        ) { }
                     }
                 }
                 """;
    }
}
